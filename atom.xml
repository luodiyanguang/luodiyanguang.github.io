<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>卡夫卡</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-30T17:35:13.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue Router</title>
    <link href="http://example.com/2020/08/28/Vue%20Router/"/>
    <id>http://example.com/2020/08/28/Vue%20Router/</id>
    <published>2020-08-28T04:20:17.000Z</published>
    <updated>2020-09-30T17:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h5><ul><li>后端路由阶段<ul><li>早期的网站开发整个<code>HTML</code>页面是由服务器来渲染的.服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.</li><li>一个页面有自己对应的网址, 也就是URL.URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理.</li><li>当我们页面中需要请求不同的<strong>路径</strong>内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端。这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化。</li></ul></li><li>前端路由阶段：<ul><li>前后端分离阶段：<ul><li>随着Ajax的出现, 有了前后端分离的开发模式.</li><li>后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中.</li><li>这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.</li><li>当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.</li></ul></li><li>单页面富应用阶段：<ul><li>在前后端分离的基础上加上一层前端路由.</li></ul></li></ul></li></ul><h5 id="二、安装和使用"><a href="#二、安装和使用" class="headerlink" title="二、安装和使用"></a>二、安装和使用</h5><ul><li><p>安装</p><blockquote><p>npm install vue-router –save</p></blockquote></li><li><p>在模块化工程中使用</p><ol><li>导入路由对象并调用Vue.use(VueRouter)</li><li>创建路由实例并传入路由映射配置</li><li>在Vue实例中挂载创建的路由实例</li></ol></li><li><p>使用vue-router的过程</p><ul><li>创建路由组件</li><li>配置路由映射</li><li>通过 <code>&lt;router-link&gt;</code> 和 <code>&lt;router-view&gt;</code>使用路由</li></ul></li><li><p>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在router/index.js中</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注入插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">//定义路由</span></span><br><span class="line"><span class="keyword">const</span> routes = []</span><br><span class="line"><span class="comment">//创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes，</span><br><span class="line">  mode: history</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//导出路由实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挂载到Vue实例上</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#App&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  rander: <span class="function"><span class="params">h</span> =&gt;</span> h(app)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用vue-router</span></span><br><span class="line"><span class="comment">//已创建路由组件home和about</span></span><br><span class="line"><span class="comment">//在router/index.js中导入并修改routers</span></span><br><span class="line"><span class="keyword">const</span> Home =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> About =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./about&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    rederict: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在App.vue中使用路由 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id &#x3D; &#39;app&#39;&gt;</span><br><span class="line">    &lt;router-link to &#x3D; &#39;&#x2F;home&#39;&gt;首页&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to &#x3D; &#39;&#x2F;about&#39;&gt;关于&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="三、动态路由匹配"><a href="#三、动态路由匹配" class="headerlink" title="三、动态路由匹配"></a>三、动态路由匹配</h5><blockquote><p>把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。我们可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br><span class="line"><span class="comment">//参数值会被设置到 this.$route.params</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">模式</th><th align="center">匹配路径</th><th align="center">$router.params</th></tr></thead><tbody><tr><td align="center">/user/:username</td><td align="center">/user/evan</td><td align="center">{username: ‘evan’}</td></tr><tr><td align="center">/user/:username/pst/:post_id</td><td align="center">/user/evan/post/123</td><td align="center">{username: ‘evan’ , post_id: ‘123’}</td></tr></tbody></table><h5 id="四、嵌套路由"><a href="#四、嵌套路由" class="headerlink" title="四、嵌套路由"></a>四、嵌套路由</h5><ul><li><p><code>&lt;router-ciew&gt;</code></p><blockquote><p><code>&lt;router-view&gt;</code> 组件是一个 functional 组件，渲染路径匹配到的视图组件。<code>&lt;router-view&gt;</code> 渲染的组件还可以内嵌自己的 <code>&lt;router-view&gt;</code>，根据嵌套路径，渲染嵌套组件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: &#123;</span><br><span class="line">    [</span><br><span class="line">    path: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    component: User,</span><br><span class="line">    children: [</span><br><span class="line">    &#123;</span><br><span class="line">    path: <span class="string">&#x27;profile&#x27;</span></span><br><span class="line">    component: UserProfile</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    component:UserPost</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>编程式导航</p><ul><li><p>点击<code>&lt;router-link ：to = &#39;...&#39;&gt;</code>进行路由跳转时，就等同于调用了<code>router.push(...)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//router.push的应用</span></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line">router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//命名路由</span></span><br><span class="line">router.push(&#123;<span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123;<span class="attr">userId</span>: <span class="string">&#x27;123&#x27;</span>&#125;&#125;)</span><br><span class="line"><span class="comment">//带查询参数，变成register?plan=private</span></span><br><span class="line">router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span> , <span class="attr">query</span>: &#123;<span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>点击<code>&lt;router-link ：to = &#39;...&#39; replace&gt;</code>进行路由跳转时,就等同于调用了<code>router.replace(...)</code></p><p>router.replace的使用方法同router.push</p></li><li><p>router.go(n)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(<span class="number">-100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="五、导航守卫"><a href="#五、导航守卫" class="headerlink" title="五、导航守卫"></a>五、导航守卫</h5><ul><li><p>基本概念</p><blockquote><p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。导航守卫就是路由跳转过程中一些钩子函数。</p></blockquote></li><li><p>全局导航守卫</p><blockquote><p>路由实例上直接操作的钩子函数，所有路由配置的组件都会触发，即触发路由就会触发这些钩子函数。</p></blockquote><ul><li><p>全局前置守卫：<code>beforeEach(to , from , next)</code></p><blockquote><p>当一个导航触发时，全局前置守卫按照创建的顺序调用，守卫是异步解析的，此时导航在所有守卫resolve完之前一直处于等待状态。可进行登陆验证。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to , <span class="keyword">from</span> , next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>to: Route</code>：即将要进入的目标路由对象</li><li><code>from:Route</code>：当前导航正要离开的路由对象</li><li><code>next:Function</code>：一定要调用该方法来resolve这个钩子，执行效果依赖于<code>next</code>方法中调用的参数<ul><li><code>next()</code>：进行管道中的下一个钩子，如果全部钩子执行完，则导航的状态就是confirmed（确认的）。</li><li><code>next(false)</code>：中断当前的导航，如果当前的URL改变了（可能是用户手动输入或者点击后退按钮），那么URL就会重置到<code>from</code>路由对应的地址。</li><li><code>next(&#39;/&#39;)</code>或者<code>next(&#123;path: &#39;/&#39;&#125;)</code>：当前导航被中断，进行一个新的导航，跳转到一个新的地址，可以向<code>next</code>传递任意地址对象。</li><li><code>next(error)</code>：导航被终止，且该错误被传递给<code>router.onError()</code>注册过的回调。</li></ul></li><li>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。</li></ul></li><li><p>全局解析守卫：<code>beforeResolve(to , from , next)</code></p><blockquote><p>你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，同时在组件内守卫和异步路由组件被解析之后，解析守卫就被调用。即在<code>beforeRouteUpdate</code>和<code>beforeRouteEnter</code>之后，在<code>afterEach</code>之前被调用。</p></blockquote></li><li><p>全局后置钩子：<code>afterEach(to , from)</code></p><blockquote><p>路由跳转完成后触发，和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身。</p></blockquote></li></ul></li><li><p>单个路由独享的导航守卫：<code>beforeEnter(to , from , next)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个路由配置上直接定义beforeEnter守卫</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter:  <span class="function">(<span class="params">to , <span class="keyword">from</span> , next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件内的导航守卫</p><blockquote><p>组件内执行的钩子函数，直接定义在组件中</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>beforeRouteEnter</code>守卫不能使用<code>this</code>，因为守卫在导航确认前被调用，即将登场的新组件还没有被创建。不过可以通过一个回调给<code>next</code>来访问组件实例。在导航被确认的时候执行回调，并把组件实例作为回调函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to , <span class="keyword">from</span> , next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过`vm`访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>beforeRouteEnter</code>是支持给<code>next</code>传递回调的唯一守卫。对于<code>beforeRouteUpdate</code>和<code>beforeRouteLeave</code>来说，<code>this</code>已经存在，不需要支持传递回调。</p></li><li><p><code>beforeRouteLeave</code>常用于禁止用户还未保存修改前突然离开，该导航可通过<code>next(false)</code>来取消。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(to , <span class="keyword">from</span> , next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(answer)&#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="六、完整的导航解析流程"><a href="#六、完整的导航解析流程" class="headerlink" title="六、完整的导航解析流程"></a>六、完整的导航解析流程</h5><ol><li>导航被触发。</li><li>在失效的组件内调用<code>beforeRouteLeave</code>守卫</li><li>调用全局的<code>beforeEach</code>守卫</li><li>在重用组件内调用<code>beforeRouteUpdate</code>守卫</li><li>在路由配置里调用<code>beforeEnter</code>守卫</li><li>解析异步路由组件。</li><li>在被激活组件里调用<code>beforeRouteEnter</code>守卫</li><li>调用全局的<code>beforeResolve</code>守卫</li><li>导航被确认。</li><li>调用全局的<code>afterEach</code>守卫</li><li>触发DOM更新。</li><li>调用<code>beforeRouteEnter</code>守卫中传递给<code>next</code>的回调函数，创建好的组件实例会作为参数传入。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;一、引入&quot;&gt;&lt;a href=&quot;#一、引入&quot; class=&quot;headerlink&quot; title=&quot;一、引入&quot;&gt;&lt;/a&gt;一、引入&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;后端路由阶段&lt;ul&gt;
&lt;li&gt;早期的网站开发整个&lt;code&gt;HTML&lt;/code&gt;页面是由服务器来渲染的.服务器</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue 组件</title>
    <link href="http://example.com/2020/08/26/Vue%20%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2020/08/26/Vue%20%E7%BB%84%E4%BB%B6/</id>
    <published>2020-08-26T08:14:16.000Z</published>
    <updated>2020-09-21T09:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、组件注册"><a href="#一、组件注册" class="headerlink" title="一、组件注册"></a>一、组件注册</h5><ul><li><p>组件名：</p><blockquote><p>html对大小写不敏感，js对大小写敏感。组件名是驼峰命名方式时，在组件被使用时需要使用短横线链接，html中attribute 也是大小写不敏感的，所以用驼峰命名法命名的组件名和attribute在使用时需要用短横线连接</p></blockquote></li><li><p>全局注册</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;component-a&#x27;</span>,&#123;<span class="comment">/***/</span>&#125;)</span><br><span class="line">Vue.component(<span class="string">&#x27;component-b,&#123;/****/&#125;)</span></span><br><span class="line">new Vue(&#123;el:&#x27;#app&#x27;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>模块系统中局部注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件componentB中注册componentA和componentC</span></span><br><span class="line"><span class="keyword">import</span> componentA <span class="keyword">from</span> <span class="string">&#x27;./componentA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> componentC <span class="keyword">from</span> <span class="string">&#x27;./componentC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    componentA,</span><br><span class="line">    componentC</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 组件componentB的模版 */</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;component-b&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="二、Prop"><a href="#二、Prop" class="headerlink" title="二、Prop"></a>二、Prop</h5><ul><li><p>传递静态或者动态的Prop</p><ul><li><p>传递动态prop：使用v-bind:props.attribute = ‘attribute’</p></li><li><p>传递静态prop</p><ul><li><p>字符串：props.attribute = ‘strings’</p></li><li><p>数字：v-bind: props.attribute = ‘number’</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component-a</span> <span class="attr">v-bind:age</span>=<span class="string">&#x27;42&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">/* 即使&#x27;42&#x27;是静态的，但是，还是需要使用`v-bind`告诉`Vue`,这是一个JavaScript表达式而不是一个字符串 */</span><br></pre></td></tr></table></figure></li><li><p>传递静态布尔值，数组字面量和对象字面量时同传递静态数字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component-a</span> <span class="attr">:is-good</span> = <span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component-b</span> <span class="attr">:result</span>= <span class="string">&#x27;[87,56,76,97]&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component-c</span> <span class="attr">:person</span> = <span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">                        name: tom,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        age: 25</span></span></span><br><span class="line"><span class="tag"><span class="string">                        &#125;&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>传入一个对象的所有属性 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:id</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>非prop的attribute</p><blockquote><p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。</p><p>组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span> <span class="attr">data-date-picker</span>=<span class="string">&quot;activated&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br><span class="line">/* data-date-picker=&quot;activated&quot; attribute 就会自动添加到 `<span class="tag">&lt;<span class="name">bootstrap-date-input</span>&gt;</span>` 的根元素上 */</span><br></pre></td></tr></table></figure></li><li><p>替换/合并已有的attribute</p><blockquote><p>对于绝大多数 <code>attribute </code>来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code> 和 <code>style</code> <code>attribute</code> 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值</p></blockquote></li></ul><h5 id="三、自定义事件"><a href="#三、自定义事件" class="headerlink" title="三、自定义事件"></a>三、自定义事件</h5><ul><li><p>事件名</p><blockquote><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以事件名需要不应该使用驼峰命名法，而应该使用短横线。</p></blockquote></li><li><p>自定义组件的v-modle</p><ul><li><p>v-modle只是语法糖，其具体的实现过程为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-modle</span>=<span class="string">&#x27;sth&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&#x27;sth&#x27;</span> @<span class="attr">input</span>=<span class="string">&#x27;sth = $event.target.value&#x27;</span>/&gt;</span></span><br><span class="line">/* 上面两者表示相同的意思，后者是前者实现的原理 */</span><br></pre></td></tr></table></figure></li><li><p>给组件添加v-modle时，默认会利用value的prop和input事件</p><blockquote><p>为了能让组件使用v-modle，这个组件内的 <code>&lt;input&gt;</code> 必须：</p><ul><li>将其 <code>value</code> attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li><li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;custom-input&#x27; , &#123;</span><br><span class="line">props: [&#x27;value&#x27;],</span><br><span class="line">template: `</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span> = <span class="string">&#x27;value&#x27;</span></span></span><br><span class="line"><span class="tag">         @<span class="attr">input</span> = <span class="string">&#x27;$emit(&#x27;</span><span class="attr">input</span>&#x27; , $<span class="attr">event.target.value</span>)&#x27;</span></span><br><span class="line"><span class="tag">   /&gt;</span></span><br><span class="line">`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* 现在v-modle可以在组件内使用了 */</span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-mmodle</span>= <span class="string">&#x27;price&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-model 应用到组件上，会有一些体验不好的场景。因为它默认会把 value 作为组件的属性，把 input作为给组件绑定事件时的事件名。可以在定义组件时通过 model 选项的方式来定制 prop/event：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 子组件 */</span><br><span class="line">export default &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;num&#x27;, // 自定义属性名</span><br><span class="line">    event: &#x27;addNum&#x27; // 自定义事件名</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: Number,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/* 在父组件中使用 */</span><br><span class="line"><span class="tag">&lt;<span class="name">my-button</span> <span class="attr">v-model</span>=<span class="string">&quot;number&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="四、插槽"><a href="#四、插槽" class="headerlink" title="四、插槽"></a>四、插槽</h5><ul><li><p>编译作用域：</p><blockquote><p>父组件模版里面的东西都会在父级作用域内编译，子组件模版里面的东西都会在子级作用 域内编译</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-con</span> <span class="attr">v-show</span>=<span class="string">&#x27;isShow&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-con</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 在父级作用域中有attribute: isShow:true , 在子级作用域中有attribute： isShow：false</span></span><br><span class="line"><span class="comment"> 该模块可以渲染并显示出来，此时，它被当作一个实例被使用，在父级作用域中，此时isShow: true</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用isShow，会看看isShow是在哪个模板里，会把cpn当做div看待，这里是在app模板里，会使用app父组件的isShow、names --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span>  <span class="comment">&lt;!-- cpn在父级模版中，被当作一个实例被使用，是父级作用域，能显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 同上，使用父级作用域中的names --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 这里是在cpn模板里，会使用cpn子组件的isShow  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        isShow: <span class="literal">true</span>,</span></span><br><span class="line">        names: [11, 22, 33]</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line"><span class="javascript">          template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">          data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              isShow: <span class="literal">false</span>,</span></span><br><span class="line">              names: [44, 55, 66]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>插槽默值：</p><blockquote><p>给插槽提供一个默认值，只会在没有给插槽提供内容时使用默认值</p></blockquote></li><li><p>具名插槽</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 插槽定义时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span> = <span class="string">&#x27;head&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插槽被实例化时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上面两行代码是没有设置name属性的slot的模版，一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名      字“default”，上面两行也可表示为</span></span><br><span class="line"><span class="comment">  &lt;template v-slot:default&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;And another one.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;/template&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>作用域插槽</p><blockquote><p>通过给slot绑定子组件的attribute实现在父级作用域中实例化组件时可以使用子组件的attribute。</p><p>绑定在<code>&lt;slot&gt;</code>上的attribute被称为插槽prop</p></blockquote></li><li><p>动态插槽名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span>  <span class="comment">&lt;!-- 定义动态插槽名 --&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>具名插槽的缩写</p><blockquote><p>把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code></p></blockquote></li></ul><h5 id="五、动态组件"><a href="#五、动态组件" class="headerlink" title="五、动态组件"></a>五、动态组件</h5><ul><li><p>动态组件</p><p>在来回切换组件的时候，组件会被重新渲染，可以通过<code>&lt;keep-alive&gt;</code>保存组件的缓存切换时不去重新渲染，可以提高效率，也能缓存上次切换之前的状态</p><blockquote><p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p></blockquote></li></ul><h5 id="六、处理边界情况"><a href="#六、处理边界情况" class="headerlink" title="六、处理边界情况"></a>六、处理边界情况</h5><ul><li><p>访问根实例： $root</p><blockquote><p>在每个 <code>new Vue</code> 实例的子组件中，其根实例可以通过 <code>$root</code> property 进行访问</p><p>当前组件树的根 Vue 实例</p></blockquote></li><li><p>访问父组件</p><blockquote><p>和 <code>$root</code> 类似，<code>$parent</code> property 可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。</p></blockquote></li><li><p>访问子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 ref 这个 attribute 为子组件赋予一个 ID 引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">&quot;usernameInput&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在父组件中通过$refs访问 --&gt;</span></span><br><span class="line">this.$refs.usernameInput</span><br></pre></td></tr></table></figure></li><li><p>依赖注入</p><p>在访问父级组件实例时，$parent比较难扩展到更深层次的组件嵌套上，而依赖注入很好的避免了这一点，它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//provide 选项允许我们指定我们想要提供给后代组件的数据/方法 </span></span><br><span class="line">        provide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            getMap: <span class="built_in">this</span>.getMap</span><br><span class="line">          &#125;;</span><br><span class="line"><span class="comment">//然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的 property：</span></span><br><span class="line">inject: [<span class="string">&#x27;getMap&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p><ul><li>祖先组件不需要知道哪些后代组件使用它提供的 property</li><li>后代组件不需要知道被注入的 property 来自哪里</li></ul></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;一、组件注册&quot;&gt;&lt;a href=&quot;#一、组件注册&quot; class=&quot;headerlink&quot; title=&quot;一、组件注册&quot;&gt;&lt;/a&gt;一、组件注册&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组件名：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;html对大小写不敏感，js对大小写敏感</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue 基础</title>
    <link href="http://example.com/2020/08/24/Vue%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2020/08/24/Vue%20%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-24T11:16:10.000Z</published>
    <updated>2020-09-17T14:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><blockquote><p>一套用于构建用户界面的渐进式框架，</p></blockquote><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ol><li><p>直接用<code>&lt;script&gt;</code>引入，Vue被注册为一个全局变量</p><ul><li><p>制作原型或学习，使用罪行版本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>对于生产环境，推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用原生的ES Modules，这里也有一个兼容 ES Module 的构建文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>NPM： 在用 Vue 构建大型应用时推荐使用 NPM 安装[<a href="https://cn.vuejs.org/v2/guide/installation.html#footnote-1">1]</a>。NPM 能很好地和诸如 <a href="https://webpack.js.org/">webpack</a> 或 <a href="http://browserify.org/">Browserify</a> 模块打包器配合使用。同时 Vue 也提供配套工具来开发<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>。</p></li></ol><h5 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h5><blockquote><p>每个Vue实例都是通过Vue函数创建的新的Vue实例</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">data: &#123;</span><br><span class="line"><span class="javascript">message: <span class="string">&quot;hello Vue&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统,当一个Vue实例被创建时，它的data对象的所有prototype均加入到Vue的响应式系统。当这些prototype 的值发生改变时，试图产生响应，匹配为最新的值。</li><li>只有当实例被创建的时候就已经存在于data中的prototype才是响应式的。如果新添加一个prototype，则对它的改变不会响应到视图。可以在刚开始的时候设置一些值使其值为空。</li></ul><h5 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h5><blockquote><p>所有的生命周期钩子都自动绑定到this的上下文实例中。因此你可以访问数据，对prototye和放大进行计算。</p></blockquote><ul><li><p>在beforeCreate和created之间的生命周期：</p><p>初始化事件，数据观测。在created的时候,数据和data进行了绑定。此时还没有el 选项。</p></li><li><p>created和beforeMount之间的生命周期：</p><p>首先判断是否有el元素，有的话继续向下编译，没有则停止编译,直到在该Vue实例上调用vm.$mount(el).</p><blockquote><p>网页中的渲染顺序：rander函数 &lt; template模版 &lt; outer选项</p></blockquote></li><li><p>beforeCreate:</p><p>在实例初始化之后，在数据观测(data observe)和event/watcher事件配置之前调用。</p></li><li><p>created：</p><p>实例创建后立即被调用，此时已经配置好的是：数据观测(data observe),prototype和方法的运算。watch/event事件回调，挂载还没有开始，$el不可用。</p></li><li><p>beforeMount：</p><p>挂载之前被调用，相关的rander函数第一次被调用，该钩子在服务器端渲染期间不能被调用。</p></li><li><p>Mounted：</p><p>实例被挂载之后调用，这时候el被新创建的vm.$el替代。<b>注意</b>,Mounted并不能保证所有的自组件也都一起挂载，如果希望等到整个视图都渲染完毕，可以在Mounted内部使用：vm.$nextTick.该钩子在服务器渲染期间不会被调用。</p></li><li><p>beforeUpdata：</p><p>数据更新时调用，发生在虚拟DOM打补丁之前，适用于在更新之前访问现有DOM,该钩子在服务器端渲染期间不被调用</p></li><li><p>Updated：</p><p>数据更改导致虚拟DOM 重新渲染和打补丁，在这之后调用该钩子。可执行依赖于DOM的操作。应该避免此期间的状态改变，可用计算属性和watch替换。updated不会保证所有的子组件都会被一起重绘，如果要等到需所有的组件都被重绘，可以在updated里面调用vm.$nextTick.</p></li><li><p>activated：</p><p>被keep-alive缓存的组件激活时调用，服务器端渲染期间不会被调用。</p></li><li><p>deactivated：</p><p>被keep-alive缓存的组件停用时调用</p></li><li><p>beforeDestroy：</p><p>实例销毁之前调用，此时实例仍然可用。</p></li><li><p>destroyed：</p><p>实例销毁后被调用，该钩子被调用后，对应的Vue指令都解绑，所有的事件监听器被移除，所有额子实例也被销毁。</p></li></ul><h5 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h5><p>Vue.j使用了基于html的模版语法，声明式的把DOM绑定至底层Vue实例数据上。在底层的实现上，Vue将模版编译成虚拟DOM渲染函数，结合响应系统，计算出最少需要重新渲染的组件并把DOM操作减少到最少。</p><ul><li><p>文本数据绑定：</p><p>Mustache语法，双大括号<code>&#123;&#123;&#125;&#125;</code>。</p></li><li><p>原始html：使用指令v-html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  use Mustaches: &#123;&#123;rawhtml&#125;&#125; <span class="comment">&lt;!-- rawhtml会被转化为字符串，不能转换为html文本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  using v-html diretive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawhtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="comment">&lt;!-- span中的内容会被转换为rawhtml中的html文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="计算属性和侦听属性"><a href="#计算属性和侦听属性" class="headerlink" title="计算属性和侦听属性"></a>计算属性和侦听属性</h5><ul><li>计算属性：computed，可以像绑定普通prototype 一样绑定计算属性</li><li>计算属性不同于普通的methods方法，它是基于响应式依赖进行缓存的，只有在响应式依赖发生改变时才会重新计算值。</li><li>计算属性的特点：<ul><li>数据可进行逻辑处理，减少模版中的计算</li><li>可以对计算属性中的值进行计算</li><li>依赖固定的数据类型（响应式数据）</li><li>计算属性有ge t和set方法组成，分别用来获取和设置计算属性，set设置属性时，不直接修改计算属性的值，而是修改它的依赖。</li></ul></li><li>计算属性和侦听属性：<ul><li>侦听属性： 比计算属性更加通用的方法来观察和响应Vue实例上的数据变动。watch中可以执行任何的逻辑，如函数节流，AJAX异步获取数据，甚至操作DOM 。使用watch时通常会用到handler回调，之后还有两个属性deep：设置为true用于监听对象内部值的变化。immediate 设置为true将立即以表达式的当前值触发回调。不加deep的话，只能监听值得变化，不能返回回调函数。</li><li>watch：监测的是属性，只要有属性的变化，都会触发执行回调函数。而computed 监测的是依赖值，只有依赖值发生改变的时候，才去重新计算。watch不能处理异步操作。</li></ul></li></ul><h5 id="Class和Style的绑定"><a href="#Class和Style的绑定" class="headerlink" title="Class和Style的绑定"></a>Class和Style的绑定</h5><blockquote><p>通过v-bind动态的绑定class和style，此时，绑定的数据可以是普通类型，也可以是一个数组，对象。v-bind可以简写为<code>:</code></p></blockquote><ul><li><p>普通动态绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&#123;active:</span> <span class="attr">isActive</span>&#125;&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- isActive的值影响到该类是否被添加上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以绑定 数组，对象，普通字符串常量</p></li><li><p>绑定在组件上：当在自定义组件上使用：组件自定义时添加class时，这些class被添加到该组件的根元素上，然后在使用它的时候再去给他动态绑定class，这时候和原来组件自定义时添加的class相互存在。</p></li><li><p>绑定内联样式：</p><p>v-bind:style 是一个JavaScript对象.CSS 中prototype名可以采用驼峰命名，也可以采用短横线分割。可以是对象，数组等。</p></li><li><p>多重值：可以给style中的prototype  提供一个包含多个值的数组，常用于提供多个带前缀的值。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样写只会渲染浏览器支持的最后一个值</p></li></ul><h5 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h5><ul><li><p>v-if 、 v-else 、 v-else-if</p></li><li><p>用key 管理 可服用组件：</p><blockquote><p>Vue会尽可能高效的渲染元素，通常会复用已有的元素。但是有时候需要把两个组件分别处理。可以给他两分别添加唯一的key值即可。渲染的时候不会再进行复用。</p></blockquote></li><li><p>v-show ：带有v-show的元素始终会被渲染并保留在DOM中，v-show只是简单的切换元素的css的display属性。</p></li><li><p>v-show不支持<code>&lt;template&gt;</code>元素，也不支持<code>v-else</code>元素</p></li><li><p>v-if和v-show的区别：</p><ul><li>v-if是真正的条件渲染，确保切换过程中条件块类事件监听器和子组件的销毁与重建。</li><li>v-if也是惰性的，它只有在判断条件为真的情况下才会去渲染条件块。初始时条件为假的话，不会渲染条件块。</li><li>v-show在什么情况下都会被渲染 ，只会是css中display属性的转换而已。</li><li>一般而言，v-if有更高的切换开销，而v-show有更高的初始化渲染开销。</li></ul></li><li><p>v-if与v-for一起使用：</p><p>二者一起使用的时候，v-for具有较高的优先级。</p></li></ul><h5 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h5><ul><li>v-for基于数组<ul><li>item in items</li><li>(item , index) in items</li></ul></li><li>v-for基于对象<ul><li>value in items</li><li>(value , index) in items</li><li>(value , name , index) in items  //value是prototype的值，name是prototype的名字，index 是索引号</li></ul></li><li>维护状态：<ul><li>当Vue更新v-for渲染的元素列表时，它默认使用“就地更新“。如果数据项的顺序被改变，Vue不会移动DOM元素匹配数据项的顺序，而是就地更改每个元素，并且确保它们的索引位置正确渲染。</li><li>这个默认的模式是高效的，但是只适用于不依赖子组件状态或者临时的DOM状态(例如：表单输入值)的列表渲染输出。</li><li>可以给每一项提供一个唯一的 key，跟踪每一个节点的身份。建议尽可能的使用key，除非遍历输出DOM的简单节点或者刻意依赖默认的行为提升性能。</li></ul></li></ul><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><ul><li><p>事件的监听：</p><p>通过v-on监听DOM事件并触发JavaScript代码。v-on可以简写为<code>@</code></p><p>对象语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span> = <span class="string">&#x27;&#123;mousedown: dothis , mouseup: doThat&#125;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修饰符:</p><ul><li>.stop：调用event.stopPropagation(),阻止事件冒泡以及事件捕获</li><li>.prevent：调用event.stopDefault()，阻止元素默认事件</li><li>.self：只当事件是从侦听器绑定的元素本身触发时才触发回调</li><li>.native：监听组件根元素的原生事件</li><li>.once：只触发一次回调</li><li>.left：只当点击鼠标左键时触发</li><li>.passive：对应addEventListener中的选项passive，设置为true时表示listener永不会调用preventDefault()。</li></ul></li></ul><h5 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h5><blockquote><p>v-model指令在表单<code>&lt;input&gt;</code> , <code>&lt;textarea&gt;</code> , <code>&lt;select&gt;</code> 元素上创建双向数据绑定。</p></blockquote><ul><li>v-modle绑定元素时使用不同的prototype和事件<ul><li>text和textarea元素使用value prototype 和input事件</li><li>checkbox和radio元素使用checked prototype和change事件</li><li>select元素使用value prototype和change事件</li></ul></li><li>修饰符<ul><li>.lazy：v-modle在每次input 事件后将输入框的值与数据进行绑定，添加lazy 修饰符后，值的绑定在change事件之后。</li><li>.number：v-modle绑定的值都会被转化为字符串 类型，可以使用.number修饰符让绑定数据自动转化为数字类型，如果这个值不能被parseFloat()解析，则返回原数据。</li><li>.trim：自动过滤用户输入的首位字符</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一套用于构建用户界面的渐进式框架，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Grid 网格布局</title>
    <link href="http://example.com/2020/08/21/Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2020/08/21/Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</id>
    <published>2020-08-21T05:25:21.000Z</published>
    <updated>2020-09-17T14:59:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h4><ul><li>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</li><li>Grid 布局与 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局</a>有一定的相似性，都可以指定容器内部多个项目的位置。Flex布局是轴线布局，只能指定项目针对轴线的位置，是一维布局。而Grid布局则是容器划分为“行”和“列“，产生单元格，可以看作是二维布局。</li><li>采用网格布局的区域称为容器，容器内部采用网格定位的子元素，称为项目，项目只能是容器的顶层子元素。</li></ul><h4 id="二、容器属性："><a href="#二、容器属性：" class="headerlink" title="二、容器属性："></a>二、容器属性：</h4><ul><li><p>display属性：</p><ul><li><p>默认情况下，容器元素都是块级元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以设置为行内元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>grid-template-columns和grid-template-rows:</p><ul><li><p>grid-template-columns定义每一列的列宽，grid-template-rows定义每一行的行高</p></li><li><p>上面两个属性常常需要设置很多重复的数值，为了方便书写，常常采用以下函数：</p><ol><li><p>repeat()：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span> , <span class="number">33.3%</span>);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span> , <span class="number">33.3%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>auto-fill关键字：</p><ul><li><p>单元格大小是固定的，而容器的大小却是不确定的，如果希望每一行(或者每一列)容纳经可能多的单元格，可以用auto-fill关键词表示自动填充。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill , <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>fr关键字:</p><ul><li><p>方便表示比例关系，采用 fr 关键字可以通过数值的比例关系设置单元格的大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>minimax()：</p><ul><li><p>minmax()函数产生一个长度的范围，接收两个参数，分别是最大值和最小值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">20px</span> <span class="number">10px</span> <span class="built_in">minmax</span>(<span class="number">50px</span> , <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>auto关键字：</p><ul><li>由浏览器自己决定长度。</li></ul></li></ol></li></ul></li><li><p>grid-row-gap属性，grid-columns-gap属性，grid-gap属性：</p><ul><li><p>grid-row-gap设置行间距，grid-columns-gap设置列间距。</p></li><li><p>grid-wap属性是grid-row-gap和grid-columns-gap属性的缩写。</p></li><li><p>根据最新的标准，三个属性前面的grid可以省略，可写为row-gap , columns-gap , gap.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">2px</span> <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>grid-template-areas属性：</p><ul><li><p>网络布局容许指定区域，一个区域由一个或多个单元格组成。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-row</span>: <span class="built_in">repeat</span>(<span class="number">3</span> , <span class="number">33.3%</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span> , <span class="number">33.3%</span>);</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                       <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                       <span class="string">&quot;footer footer footer&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>grid-auto-flow属性：容器内子元素的排列顺序</p><ul><li>row：（默认)先行后列，先填满第一行，之后开始第二行。</li><li>column：先列后行</li><li>row  dense ：先行后列，尽可能的紧密填满，尽量不出现空格。</li><li>column  dense ：先列后行，尽可能的紧密填满，尽量不出现空格。</li></ul></li><li><p>justify-items , align-items , place-items 属性:</p><ul><li>justify-items属性设置单元格内容的水平位置(左中右) </li><li>align-items设置单元格内容的垂直内容（上中下）</li><li>place-items属性是justify-items和align-items属性的合并<ul><li>start ：对齐单元格的起始位置</li><li>end：对齐单元格的终止位置</li><li>center：单元格内部居中</li><li>stretch：（默认）拉伸，占满单元格的整个宽度</li></ul></li></ul></li><li><p>justify-content , align-content , place-content属性：</p><ul><li>justify-content属性是整个内容区在容器中的水平位置（左中右）</li><li>align-content属性是整个内容区在容器中的垂直位置（上中下）</li><li>place-content属性是justify-content和align-content属性的合并<ul><li>start , end ,center , stretch同上</li><li>space-around：每个项目两侧的间隔相等，项目之间的间隔是项目与边框之间距离的二倍</li><li>space-between：项目之间间隔相等，项目与边框没有间隔。</li><li>space-evenly：项目之间间隔相等，项目与边框之间的距离也和项目之间的距离相等。</li></ul></li></ul></li><li><p>grid-auto-columns , grid-auto-raws属性：</p><blockquote><p>有时候，一些项目指定位置在现有网格的外部，这时，浏览器会自动生成多余的网格，以便放置项目。grid-auto-columns和grid-auto-raws用来设置浏览器自动生成网格的列宽和行高。写法同grid-template-columns和grid-template-raws。如果不指定这两个值的话，浏览器完全按照单元格内容的大小决定新增网格的列宽和行高。</p></blockquote></li></ul><h4 id="三、项目属性"><a href="#三、项目属性" class="headerlink" title="三、项目属性"></a>三、项目属性</h4><ul><li><p>grid-column-start , grid-column-end , grid-raw-start , grid-raw-end属性：</p><ul><li>grid-column-start：左边框所在的垂直网线格</li><li>grid-column-end：有边框所在的垂直网线格</li><li>grid-raw-start , grid-raw-end类似于上面两项</li></ul></li><li><p>grid-column ， grid-raw属性</p><ul><li>grid-column是grid-column-start和grid-column-end的合并</li><li>grid-raw是grid-raw-start和grid-raw-end的合并</li></ul></li><li><p>grid-area属性：指定项目放在哪一个区域</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目被放置在e区域</p></li><li><p>justify-self  , align-self , place-self属性</p><ul><li>justify-self：设置单元格内容的水平位置，与justify-items的用法相同，但是只能作用于单个项目 </li><li>align-self：设置单元格内容的垂直位置，与align-items用法相同，但只能作用于单个项目</li><li>place-self：align-self和justify-self的合并</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、基本概念：&quot;&gt;&lt;a href=&quot;#一、基本概念：&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念：&quot;&gt;&lt;/a&gt;一、基本概念：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FLex 布局</title>
    <link href="http://example.com/2020/08/20/Flex%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2020/08/20/Flex%E5%B8%83%E5%B1%80/</id>
    <published>2020-08-20T07:30:09.000Z</published>
    <updated>2020-09-17T14:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持</p></blockquote><h4 id="一、Flex布局是什么："><a href="#一、Flex布局是什么：" class="headerlink" title="一、Flex布局是什么："></a>一、Flex布局是什么：</h4><ul><li><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>行内元素也可以使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Webkit内核的浏览器，必须加上-webkit前缀：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;  <span class="comment">/* safsri */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>设为Flex布局以后，子元素的 float ,clear ,vertical-align属性将会失效</em></p></li></ul><h4 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h4><ul><li>采用Flex布局的元素，称为容器，他的所有子元素自动成为容器的项目。容器默认存在两根轴(main axis），水平的主轴和垂直的交叉轴(cross axis)。</li><li>项目默认是沿着主轴排列的，单个项目占据主轴的空间叫做main-size,占据的交叉空间叫做cross-size</li></ul><h4 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h4><ul><li>flex-direction：决定项目排列的方向<ul><li>row(默认属性)：主轴在水平方向，起点在左边</li><li>row-reserv： 主轴在水平方向上，起点在右边</li><li>column：主轴在垂直方向上，起点在上边</li><li>column-reserve：主轴在垂直方向上，起点在下边</li></ul></li><li>flex-wrap：默认情况下，所有的项目都是排列在一条轴线上的，flex-wrap设置是否换行<ul><li>now rap：不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reserve：换行，第一行在下方</li></ul></li><li>flex-flow：flex-direction和flex-wrap的简写，默认为row nowrap</li><li>justify-content：项目在主轴上的对齐方式<ul><li>flex-start：(默认)，左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目间隔相等</li><li>space-around：项目之间间隔相等，但项目之间间隔是项目与边框之间间隔的二倍</li></ul></li><li>align-item：项目在交叉轴线上的对齐方式<ul><li>flex-start：交叉轴的起点对齐</li><li>flex-end：交叉轴的终点对齐</li><li>center：交叉轴的中点对齐</li><li>baseline：项目的第一行文字的基线对齐 </li><li>stretch：(默认值)，如果未设置项目的高度或者高度为auto，将占满整个容器的高度</li></ul></li><li>align-content：多跟轴线的对齐方式，如果只有一条轴线，该属性不起作用<ul><li>flex-start：与交叉轴的起点对齐</li><li>flex-end：与交叉轴的终点对齐</li><li>center：与交叉轴中点对齐</li><li>space-between：与交叉轴两端对齐，轴线之间间隔平均分配</li><li>space-around：两条轴线两侧的间隔相等，轴线之间的间隔是轴线与边框间隔的二倍</li><li>stretch：(默认值),轴线占满整个交叉轴</li></ul></li></ul><h4 id="四、项目属性："><a href="#四、项目属性：" class="headerlink" title="四、项目属性："></a>四、项目属性：</h4><ul><li><p>order：项目的排列顺序，数值越小，排列越靠前，默认为0，可为负数</p></li><li><p>flex-grow：项目放大比例</p><blockquote><p>默认为0，即使存在剩余空间也不会被放大</p><p>如果所有项目的flex-grow属性都是1，则它们等分剩余空间(如果有的话)</p><p>如果一个项目flex-grow为2，其余项目的均为1，则前者占据的剩余的空间是其他项目的二倍</p></blockquote></li><li><p>flex-shrink：项目的缩小比例</p><blockquote><p>默认为1，如果空间不足，项目将缩小</p><p>如果所有的项目flex-shrink均为1，当空间不足时，所有项目等比例缩小</p><p>如果一个项目的flex-shrinkk为0，其余的均为1，则该项目不缩小，其余项目等比例缩小</p><p>flex-shrink属性值为负数时无效</p></blockquote></li><li><p>flex-basis：该属性定义了在分配多余空间之前，项目占据的主轴空间(main-size),浏览器根据这个属性，计算主轴是否有多余的空间</p><blockquote><p>默认为0，即为项目本来的空间大小</p><p>可以设置为跟width和height属性一样的值，项目占据固定空间</p></blockquote></li><li><p>flex：是flex-gro、flex-shrink、flex-basis的缩写，默认为 0 1 auto,后面两个属性可选。</p></li><li><p>align-self：容许单个项目与其他项目有不一样的对齐方式，可覆盖align-item，默认值为auto。表示继承父元素的align-item的属性，如果没有父元素，等同于stretch</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一、Flex布局是什么：&quot;&gt;&lt;a href=&quot;#一、Flex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTML 知识点总结</title>
    <link href="http://example.com/2020/08/15/HTML%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/08/15/HTML%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-15T11:52:03.000Z</published>
    <updated>2020-09-17T13:37:31.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、DOCTYPE标签："><a href="#一、DOCTYPE标签：" class="headerlink" title="一、DOCTYPE标签："></a>一、DOCTYPE标签：</h4><ul><li>DOCTYPE声明不是HTML标签，是用于指示WEB浏览器关于页面使用那种HTML版本进行编写指令，规定了浏览器文档使用哪种html或者xhtml规范。</li><li>可以防止浏览器在渲染文档时，切换到怪异模式（兼容模式）用浏览器自身的渲染模式，确保浏览器按照W3C标准来渲染解析页面。</li></ul><h4 id="二、meta元数据："><a href="#二、meta元数据：" class="headerlink" title="二、meta元数据："></a>二、meta元数据：</h4><ul><li>不会显示在页面上，但是对于机器是可读的。meta常用于规定页面的描述，关键词，文档作者以及最后修改时间等</li><li>一些搜索引擎会根据meta元素的name和content属性来索引界面</li></ul><h4 id="三、script标签放在body元素后面的原因："><a href="#三、script标签放在body元素后面的原因：" class="headerlink" title="三、script标签放在body元素后面的原因："></a>三、script标签放在body元素后面的原因：</h4><ul><li>因为浏览器在渲染html时是按照从上往下依次顺序进行的，当遇到js文件时，会停止当前页面的渲染，转而去下载js文件，把js文件放在文档开头时，当遇到文件很大的时候，页面延时时间过长，影响用户体验。解决方法：<ol><li>把 js 文件放到body元素后面</li><li>通过defer\async属性将 js 文件转为异步下载</li></ol></li><li>defer\async都是让 js 文件异步加载，不同的是，前者需要在整个文档渲染完成才执行，而后者在下载完成后会暂停html的解析，转去执行 js 文件</li></ul><h4 id="四、src和href的区别："><a href="#四、src和href的区别：" class="headerlink" title="四、src和href的区别："></a>四、src和href的区别：</h4><p>href是超文本引用，指向    资源的位置，建立与目标文件之间的联系；src目标是把资源下载到页面中。浏览器解析方式href不会阻塞对文档的处理，而src会阻塞对文档的处理</p><h4 id="五、行内元素和块级元素："><a href="#五、行内元素和块级元素：" class="headerlink" title="五、行内元素和块级元素："></a>五、行内元素和块级元素：</h4><ul><li>分类<ol><li>常见的块级元素：adress , div , h1~h6 , p , hr , ol , ul , li , table , tr , form , nav , header , article , aside ,  section , footer , canvas , audio </li><li>常见的行内元素： a , span , br , img , lable , input , textarea , video</li><li>可变元素： button , map</li></ol></li><li>区别：<ol><li>块级元素总是在新行上开始，可以设置宽度和高度，不设置的话继承父元素的宽度。块级元素可以容纳行内元素和其他元素</li><li>行内元素都排列在同一行，width和height不可设置，但是line-height可以设置，设置margin时只对左右有效，而padding四面都是有效的。</li></ol></li></ul><h4 id="六、div-模拟textarea"><a href="#六、div-模拟textarea" class="headerlink" title="六、div 模拟textarea:"></a>六、div 模拟textarea:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.textarea</span> &#123;</span></span><br><span class="line">width: 400px;</span><br><span class="line">min-height: 60px;</span><br><span class="line">max-height: 300px;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">overflow-x: hidden;</span><br><span class="line">overflow-y: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textarea&quot;</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​                              </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、DOCTYPE标签：&quot;&gt;&lt;a href=&quot;#一、DOCTYPE标签：&quot; class=&quot;headerlink&quot; title=&quot;一、DOCTYPE标签：&quot;&gt;&lt;/a&gt;一、DOCTYPE标签：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;DOCTYPE声明不是HTML标签，是用于指示W</summary>
      
    
    
    
    
  </entry>
  
</feed>
