{"meta":{"title":"卡夫卡","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Vue 基础","slug":"Vue 基础","date":"2020-08-24T11:16:10.000Z","updated":"2020-09-17T14:59:37.000Z","comments":true,"path":"2020/08/24/Vue 基础/","link":"","permalink":"http://example.com/2020/08/24/Vue%20%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、基本概念 一套用于构建用户界面的渐进式框架， 安装 直接用&lt;script&gt;引入，Vue被注册为一个全局变量 制作原型或学习，使用罪行版本： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 对于生产环境，推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;&gt;&lt;/script&gt; 使用原生的ES Modules，这里也有一个兼容 ES Module 的构建文件： 123&lt;script type=&quot;module&quot;&gt; import Vue from &#x27;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&#x27;&lt;/script&gt; NPM： 在用 Vue 构建大型应用时推荐使用 NPM 安装[1]。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。 Vue实例 每个Vue实例都是通过Vue函数创建的新的Vue实例 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;hello Vue&quot; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统,当一个Vue实例被创建时，它的data对象的所有prototype均加入到Vue的响应式系统。当这些prototype 的值发生改变时，试图产生响应，匹配为最新的值。 只有当实例被创建的时候就已经存在于data中的prototype才是响应式的。如果新添加一个prototype，则对它的改变不会响应到视图。可以在刚开始的时候设置一些值使其值为空。 生命周期钩子 所有的生命周期钩子都自动绑定到this的上下文实例中。因此你可以访问数据，对prototye和放大进行计算。 在beforeCreate和created之间的生命周期： 初始化事件，数据观测。在created的时候,数据和data进行了绑定。此时还没有el 选项。 created和beforeMount之间的生命周期： 首先判断是否有el元素，有的话继续向下编译，没有则停止编译,直到在该Vue实例上调用vm.$mount(el). 网页中的渲染顺序：rander函数 &lt; template模版 &lt; outer选项 beforeCreate: 在实例初始化之后，在数据观测(data observe)和event/watcher事件配置之前调用。 created： 实例创建后立即被调用，此时已经配置好的是：数据观测(data observe),prototype和方法的运算。watch/event事件回调，挂载还没有开始，$el不可用。 beforeMount： 挂载之前被调用，相关的rander函数第一次被调用，该钩子在服务器端渲染期间不能被调用。 Mounted： 实例被挂载之后调用，这时候el被新创建的vm.$el替代。注意,Mounted并不能保证所有的自组件也都一起挂载，如果希望等到整个视图都渲染完毕，可以在Mounted内部使用：vm.$nextTick.该钩子在服务器渲染期间不会被调用。 beforeUpdata： 数据更新时调用，发生在虚拟DOM打补丁之前，适用于在更新之前访问现有DOM,该钩子在服务器端渲染期间不被调用 Updated： 数据更改导致虚拟DOM 重新渲染和打补丁，在这之后调用该钩子。可执行依赖于DOM的操作。应该避免此期间的状态改变，可用计算属性和watch替换。updated不会保证所有的子组件都会被一起重绘，如果要等到需所有的组件都被重绘，可以在updated里面调用vm.$nextTick. activated： 被keep-alive缓存的组件激活时调用，服务器端渲染期间不会被调用。 deactivated： 被keep-alive缓存的组件停用时调用 beforeDestroy： 实例销毁之前调用，此时实例仍然可用。 destroyed： 实例销毁后被调用，该钩子被调用后，对应的Vue指令都解绑，所有的事件监听器被移除，所有额子实例也被销毁。 模版语法Vue.j使用了基于html的模版语法，声明式的把DOM绑定至底层Vue实例数据上。在底层的实现上，Vue将模版编译成虚拟DOM渲染函数，结合响应系统，计算出最少需要重新渲染的组件并把DOM操作减少到最少。 文本数据绑定： Mustache语法，双大括号&#123;&#123;&#125;&#125;。 原始html：使用指令v-html 123456&lt;p&gt; use Mustaches: &#123;&#123;rawhtml&#125;&#125; &lt;!-- rawhtml会被转化为字符串，不能转换为html文本 --&gt;&lt;/p&gt;&lt;p&gt; using v-html diretive: &lt;span v-html=&quot;rawhtml&quot;&gt;&lt;/span&gt; &lt;!-- span中的内容会被转换为rawhtml中的html文件 --&gt;&lt;/p&gt; 计算属性和侦听属性 计算属性：computed，可以像绑定普通prototype 一样绑定计算属性 计算属性不同于普通的methods方法，它是基于响应式依赖进行缓存的，只有在响应式依赖发生改变时才会重新计算值。 计算属性的特点： 数据可进行逻辑处理，减少模版中的计算 可以对计算属性中的值进行计算 依赖固定的数据类型（响应式数据） 计算属性有ge t和set方法组成，分别用来获取和设置计算属性，set设置属性时，不直接修改计算属性的值，而是修改它的依赖。 计算属性和侦听属性： 侦听属性： 比计算属性更加通用的方法来观察和响应Vue实例上的数据变动。watch中可以执行任何的逻辑，如函数节流，AJAX异步获取数据，甚至操作DOM 。使用watch时通常会用到handler回调，之后还有两个属性deep：设置为true用于监听对象内部值的变化。immediate 设置为true将立即以表达式的当前值触发回调。不加deep的话，只能监听值得变化，不能返回回调函数。 watch：监测的是属性，只要有属性的变化，都会触发执行回调函数。而computed 监测的是依赖值，只有依赖值发生改变的时候，才去重新计算。watch不能处理异步操作。 Class和Style的绑定 通过v-bind动态的绑定class和style，此时，绑定的数据可以是普通类型，也可以是一个数组，对象。v-bind可以简写为: 普通动态绑定： 123&lt;div :class=&#123;active: isActive&#125;&gt; &lt;!-- isActive的值影响到该类是否被添加上 --&gt;&lt;/div&gt; 也可以绑定 数组，对象，普通字符串常量 绑定在组件上：当在自定义组件上使用：组件自定义时添加class时，这些class被添加到该组件的根元素上，然后在使用它的时候再去给他动态绑定class，这时候和原来组件自定义时添加的class相互存在。 绑定内联样式： v-bind:style 是一个JavaScript对象.CSS 中prototype名可以采用驼峰命名，也可以采用短横线分割。可以是对象，数组等。 多重值：可以给style中的prototype 提供一个包含多个值的数组，常用于提供多个带前缀的值。例如： 1&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt; 这样写只会渲染浏览器支持的最后一个值 条件渲染 v-if 、 v-else 、 v-else-if 用key 管理 可服用组件： Vue会尽可能高效的渲染元素，通常会复用已有的元素。但是有时候需要把两个组件分别处理。可以给他两分别添加唯一的key值即可。渲染的时候不会再进行复用。 v-show ：带有v-show的元素始终会被渲染并保留在DOM中，v-show只是简单的切换元素的css的display属性。 v-show不支持&lt;template&gt;元素，也不支持v-else元素 v-if和v-show的区别： v-if是真正的条件渲染，确保切换过程中条件块类事件监听器和子组件的销毁与重建。 v-if也是惰性的，它只有在判断条件为真的情况下才会去渲染条件块。初始时条件为假的话，不会渲染条件块。 v-show在什么情况下都会被渲染 ，只会是css中display属性的转换而已。 一般而言，v-if有更高的切换开销，而v-show有更高的初始化渲染开销。 v-if与v-for一起使用： 二者一起使用的时候，v-for具有较高的优先级。 列表渲染 v-for基于数组 item in items (item , index) in items v-for基于对象 value in items (value , index) in items (value , name , index) in items //value是prototype的值，name是prototype的名字，index 是索引号 维护状态： 当Vue更新v-for渲染的元素列表时，它默认使用“就地更新“。如果数据项的顺序被改变，Vue不会移动DOM元素匹配数据项的顺序，而是就地更改每个元素，并且确保它们的索引位置正确渲染。 这个默认的模式是高效的，但是只适用于不依赖子组件状态或者临时的DOM状态(例如：表单输入值)的列表渲染输出。 可以给每一项提供一个唯一的 key，跟踪每一个节点的身份。建议尽可能的使用key，除非遍历输出DOM的简单节点或者刻意依赖默认的行为提升性能。 事件处理 事件的监听： 通过v-on监听DOM事件并触发JavaScript代码。v-on可以简写为@ 对象语法： 1&lt;button v-on = &#x27;&#123;mousedown: dothis , mouseup: doThat&#125;&#x27;&gt;&lt;/button&gt; 修饰符: .stop：调用event.stopPropagation(),阻止事件冒泡以及事件捕获 .prevent：调用event.stopDefault()，阻止元素默认事件 .self：只当事件是从侦听器绑定的元素本身触发时才触发回调 .native：监听组件根元素的原生事件 .once：只触发一次回调 .left：只当点击鼠标左键时触发 .passive：对应addEventListener中的选项passive，设置为true时表示listener永不会调用preventDefault()。 表单输入绑定 v-model指令在表单&lt;input&gt; , &lt;textarea&gt; , &lt;select&gt; 元素上创建双向数据绑定。 v-modle绑定元素时使用不同的prototype和事件 text和textarea元素使用value prototype 和input事件 checkbox和radio元素使用checked prototype和change事件 select元素使用value prototype和change事件 修饰符 .lazy：v-modle在每次input 事件后将输入框的值与数据进行绑定，添加lazy 修饰符后，值的绑定在change事件之后。 .number：v-modle绑定的值都会被转化为字符串 类型，可以使用.number修饰符让绑定数据自动转化为数字类型，如果这个值不能被parseFloat()解析，则返回原数据。 .trim：自动过滤用户输入的首位字符","categories":[],"tags":[]},{"title":"Grid 网格布局","slug":"Grid网格布局","date":"2020-08-21T05:25:21.000Z","updated":"2020-09-17T14:59:33.000Z","comments":true,"path":"2020/08/21/Grid网格布局/","link":"","permalink":"http://example.com/2020/08/21/Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"一、基本概念： 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。 Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。Flex布局是轴线布局，只能指定项目针对轴线的位置，是一维布局。而Grid布局则是容器划分为“行”和“列“，产生单元格，可以看作是二维布局。 采用网格布局的区域称为容器，容器内部采用网格定位的子元素，称为项目，项目只能是容器的顶层子元素。 二、容器属性： display属性： 默认情况下，容器元素都是块级元素。 123div &#123; display: grid;&#125; 也可以设置为行内元素。 123div &#123; display: inline-grid;&#125; grid-template-columns和grid-template-rows: grid-template-columns定义每一列的列宽，grid-template-rows定义每一行的行高 上面两个属性常常需要设置很多重复的数值，为了方便书写，常常采用以下函数： repeat()： 12345div &#123; display: grid; grid-template-columns: repeat(3 , 33.3%); grid-template-rows: repeat(3 , 33.3%);&#125; auto-fill关键字： 单元格大小是固定的，而容器的大小却是不确定的，如果希望每一行(或者每一列)容纳经可能多的单元格，可以用auto-fill关键词表示自动填充。 1234div &#123; display: grid; grid-template-columns: repeat(auto-fill , 20px);&#125; fr关键字: 方便表示比例关系，采用 fr 关键字可以通过数值的比例关系设置单元格的大小。 1234div &#123; display: grid; grid-template-columns: 1fr 1fr 2fr;&#125; minimax()： minmax()函数产生一个长度的范围，接收两个参数，分别是最大值和最小值。 1234div &#123; display: grid; grid-template-columns: 20px 10px minmax(50px , 100px);&#125; auto关键字： 由浏览器自己决定长度。 grid-row-gap属性，grid-columns-gap属性，grid-gap属性： grid-row-gap设置行间距，grid-columns-gap设置列间距。 grid-wap属性是grid-row-gap和grid-columns-gap属性的缩写。 根据最新的标准，三个属性前面的grid可以省略，可写为row-gap , columns-gap , gap. 1234.container &#123; display: grid; gap: 2px 3px;&#125; grid-template-areas属性： 网络布局容许指定区域，一个区域由一个或多个单元格组成。 12345678container &#123; display: grid; grid-template-row: repeat(3 , 33.3%); grid-template-columns: repeat(3 , 33.3%); grid-template-areas: &quot;header header header&quot; &quot;main main sidebar&quot; &quot;footer footer footer&quot;&#125; grid-auto-flow属性：容器内子元素的排列顺序 row：（默认)先行后列，先填满第一行，之后开始第二行。 column：先列后行 row dense ：先行后列，尽可能的紧密填满，尽量不出现空格。 column dense ：先列后行，尽可能的紧密填满，尽量不出现空格。 justify-items , align-items , place-items 属性: justify-items属性设置单元格内容的水平位置(左中右) align-items设置单元格内容的垂直内容（上中下） place-items属性是justify-items和align-items属性的合并 start ：对齐单元格的起始位置 end：对齐单元格的终止位置 center：单元格内部居中 stretch：（默认）拉伸，占满单元格的整个宽度 justify-content , align-content , place-content属性： justify-content属性是整个内容区在容器中的水平位置（左中右） align-content属性是整个内容区在容器中的垂直位置（上中下） place-content属性是justify-content和align-content属性的合并 start , end ,center , stretch同上 space-around：每个项目两侧的间隔相等，项目之间的间隔是项目与边框之间距离的二倍 space-between：项目之间间隔相等，项目与边框没有间隔。 space-evenly：项目之间间隔相等，项目与边框之间的距离也和项目之间的距离相等。 grid-auto-columns , grid-auto-raws属性： 有时候，一些项目指定位置在现有网格的外部，这时，浏览器会自动生成多余的网格，以便放置项目。grid-auto-columns和grid-auto-raws用来设置浏览器自动生成网格的列宽和行高。写法同grid-template-columns和grid-template-raws。如果不指定这两个值的话，浏览器完全按照单元格内容的大小决定新增网格的列宽和行高。 三、项目属性 grid-column-start , grid-column-end , grid-raw-start , grid-raw-end属性： grid-column-start：左边框所在的垂直网线格 grid-column-end：有边框所在的垂直网线格 grid-raw-start , grid-raw-end类似于上面两项 grid-column ， grid-raw属性 grid-column是grid-column-start和grid-column-end的合并 grid-raw是grid-raw-start和grid-raw-end的合并 grid-area属性：指定项目放在哪一个区域 123.item-1 &#123; grid-area: e;&#125; 项目被放置在e区域 justify-self , align-self , place-self属性 justify-self：设置单元格内容的水平位置，与justify-items的用法相同，但是只能作用于单个项目 align-self：设置单元格内容的垂直位置，与align-items用法相同，但只能作用于单个项目 place-self：align-self和justify-self的合并","categories":[],"tags":[]},{"title":"FLex 布局","slug":"Flex布局","date":"2020-08-20T07:30:09.000Z","updated":"2020-09-17T14:59:31.000Z","comments":true,"path":"2020/08/20/Flex布局/","link":"","permalink":"http://example.com/2020/08/20/Flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持 一、Flex布局是什么： Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。 123.box &#123; display: flex;&#125; 行内元素也可以使用： 123.box &#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀： 1234.box &#123; display: -webkit-flex; /* safsri */ display: flex;&#125; 设为Flex布局以后，子元素的 float ,clear ,vertical-align属性将会失效 二、基本概念 采用Flex布局的元素，称为容器，他的所有子元素自动成为容器的项目。容器默认存在两根轴(main axis），水平的主轴和垂直的交叉轴(cross axis)。 项目默认是沿着主轴排列的，单个项目占据主轴的空间叫做main-size,占据的交叉空间叫做cross-size 三、容器的属性 flex-direction：决定项目排列的方向 row(默认属性)：主轴在水平方向，起点在左边 row-reserv： 主轴在水平方向上，起点在右边 column：主轴在垂直方向上，起点在上边 column-reserve：主轴在垂直方向上，起点在下边 flex-wrap：默认情况下，所有的项目都是排列在一条轴线上的，flex-wrap设置是否换行 now rap：不换行 wrap：换行，第一行在上方 wrap-reserve：换行，第一行在下方 flex-flow：flex-direction和flex-wrap的简写，默认为row nowrap justify-content：项目在主轴上的对齐方式 flex-start：(默认)，左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目间隔相等 space-around：项目之间间隔相等，但项目之间间隔是项目与边框之间间隔的二倍 align-item：项目在交叉轴线上的对齐方式 flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch：(默认值)，如果未设置项目的高度或者高度为auto，将占满整个容器的高度 align-content：多跟轴线的对齐方式，如果只有一条轴线，该属性不起作用 flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴中点对齐 space-between：与交叉轴两端对齐，轴线之间间隔平均分配 space-around：两条轴线两侧的间隔相等，轴线之间的间隔是轴线与边框间隔的二倍 stretch：(默认值),轴线占满整个交叉轴 四、项目属性： order：项目的排列顺序，数值越小，排列越靠前，默认为0，可为负数 flex-grow：项目放大比例 默认为0，即使存在剩余空间也不会被放大 如果所有项目的flex-grow属性都是1，则它们等分剩余空间(如果有的话) 如果一个项目flex-grow为2，其余项目的均为1，则前者占据的剩余的空间是其他项目的二倍 flex-shrink：项目的缩小比例 默认为1，如果空间不足，项目将缩小 如果所有的项目flex-shrink均为1，当空间不足时，所有项目等比例缩小 如果一个项目的flex-shrinkk为0，其余的均为1，则该项目不缩小，其余项目等比例缩小 flex-shrink属性值为负数时无效 flex-basis：该属性定义了在分配多余空间之前，项目占据的主轴空间(main-size),浏览器根据这个属性，计算主轴是否有多余的空间 默认为0，即为项目本来的空间大小 可以设置为跟width和height属性一样的值，项目占据固定空间 flex：是flex-gro、flex-shrink、flex-basis的缩写，默认为 0 1 auto,后面两个属性可选。 align-self：容许单个项目与其他项目有不一样的对齐方式，可覆盖align-item，默认值为auto。表示继承父元素的align-item的属性，如果没有父元素，等同于stretch","categories":[],"tags":[]},{"title":"HTML 知识点总结","slug":"HTML 知识点总结","date":"2020-08-15T11:52:03.000Z","updated":"2020-09-17T13:37:31.000Z","comments":true,"path":"2020/08/15/HTML 知识点总结/","link":"","permalink":"http://example.com/2020/08/15/HTML%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、DOCTYPE标签： DOCTYPE声明不是HTML标签，是用于指示WEB浏览器关于页面使用那种HTML版本进行编写指令，规定了浏览器文档使用哪种html或者xhtml规范。 可以防止浏览器在渲染文档时，切换到怪异模式（兼容模式）用浏览器自身的渲染模式，确保浏览器按照W3C标准来渲染解析页面。 二、meta元数据： 不会显示在页面上，但是对于机器是可读的。meta常用于规定页面的描述，关键词，文档作者以及最后修改时间等 一些搜索引擎会根据meta元素的name和content属性来索引界面 三、script标签放在body元素后面的原因： 因为浏览器在渲染html时是按照从上往下依次顺序进行的，当遇到js文件时，会停止当前页面的渲染，转而去下载js文件，把js文件放在文档开头时，当遇到文件很大的时候，页面延时时间过长，影响用户体验。解决方法： 把 js 文件放到body元素后面 通过defer\\async属性将 js 文件转为异步下载 defer\\async都是让 js 文件异步加载，不同的是，前者需要在整个文档渲染完成才执行，而后者在下载完成后会暂停html的解析，转去执行 js 文件 四、src和href的区别：href是超文本引用，指向 资源的位置，建立与目标文件之间的联系；src目标是把资源下载到页面中。浏览器解析方式href不会阻塞对文档的处理，而src会阻塞对文档的处理 五、行内元素和块级元素： 分类 常见的块级元素：adress , div , h1~h6 , p , hr , ol , ul , li , table , tr , form , nav , header , article , aside , section , footer , canvas , audio 常见的行内元素： a , span , br , img , lable , input , textarea , video 可变元素： button , map 区别： 块级元素总是在新行上开始，可以设置宽度和高度，不设置的话继承父元素的宽度。块级元素可以容纳行内元素和其他元素 行内元素都排列在同一行，width和height不可设置，但是line-height可以设置，设置margin时只对左右有效，而padding四面都是有效的。 六、div 模拟textarea:1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .textarea &#123; width: 400px; min-height: 60px; max-height: 300px; margin: 0 auto; overflow-x: hidden; overflow-y: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;textarea&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ​","categories":[],"tags":[]}],"categories":[],"tags":[]}